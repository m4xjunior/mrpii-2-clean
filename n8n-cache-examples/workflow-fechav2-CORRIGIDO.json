{
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "fechav2",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [288, -128],
      "id": "webhook",
      "name": "Webhook"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "cof-field",
              "name": "cof",
              "value": "={{ $json.body[0].body.codigo_of }}",
              "type": "string"
            },
            {
              "id": "machineId-field",
              "name": "machineId",
              "value": "={{ $json.body[0].body.machineId }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [480, -112],
      "id": "edit-fields",
      "name": "Edit Fields - Extract COF"
    },
    {
      "parameters": {
        "operation": "get",
        "key": "=cache:fechas:{{ $json.cof }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [640, -112],
      "id": "redis-get",
      "name": "Redis Get",
      "credentials": {
        "redis": {
          "id": "Lrhc8rOAXwUSQ4SQ",
          "name": "REDISLOCAL"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "cache-check",
              "leftValue": "={{ $json.propertyName }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "empty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [800, -112],
      "id": "if-cache-exists",
      "name": "Cache Exists?"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n    ho.cod_of as codigo_of,\n    ho.Desc_of as descricao,\n    ho.Fecha_ini as data_inicio_planejada,\n    ho.Fecha_fin as data_fim_planejada,\n    ho.Fecha_entrega as data_entrega,\n    MIN(hp.fecha_ini) as data_inicio_real,\n    CASE \n        WHEN SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_repro) > 0 \n        THEN CAST(\n            SUM(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin)) * 1.0 / \n            SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_repro)\n            AS DECIMAL(18,4))\n        ELSE 0 \n    END as tiempo_medio_por_pieza_segundos,\n    CASE \n        WHEN SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_repro) > 0\n        THEN DATEADD(SECOND,\n                CAST(\n                    (SUM(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin)) * 1.0 / \n                     SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_repro)) *\n                    (ho.Unidades_planning - SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_repro))\n                    AS BIGINT),\n                GETDATE())\n        ELSE NULL\n    END as data_fim_estimada,\n    CASE \n        WHEN SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_repro) > 0\n        THEN CAST(\n            (SUM(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin)) * 1.0 / \n             SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_repro)) *\n            (ho.Unidades_planning - SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_repro))\n            AS BIGINT)\n        ELSE 0\n    END as tiempo_restante_segundos,\n    CASE \n        WHEN SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_repro) > 0 \n        THEN CAST(\n            ((SUM(DATEDIFF(SECOND, hp.fecha_ini, hp.fecha_fin)) * 1.0 / \n              SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_repro)) *\n             (ho.Unidades_planning - SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_repro))) / 3600.0\n            AS DECIMAL(10,2))\n        ELSE 0 \n    END as tiempo_restante_horas,\n    ho.Unidades_planning as quantidade_planejada,\n    SUM(hp.unidades_ok) as unidades_ok,\n    SUM(hp.unidades_nok) as unidades_nok,\n    SUM(hp.unidades_repro) as unidades_rw,\n    SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_repro) as total_producido,\n    ho.Unidades_planning - SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_repro) as piezas_faltantes,\n    CASE \n        WHEN ho.Unidades_planning > 0 \n        THEN CAST(\n            (SUM(hp.unidades_ok + hp.unidades_nok + hp.unidades_repro) * 100.0 / ho.Unidades_planning)\n            AS DECIMAL(5,2))\n        ELSE 0 \n    END as porcentaje_completado,\n    GETDATE() as data_calculo_sql,\n    ho.Activo as ativo\nFROM his_of ho WITH (NOLOCK)\nINNER JOIN his_fase hf WITH (NOLOCK) ON ho.id_his_of = hf.id_his_of\nINNER JOIN his_prod hp WITH (NOLOCK) ON hf.id_his_fase = hp.id_his_fase\nWHERE ho.Activo = 1\n    AND ho.cod_of = '{{ $('edit-fields').item.json.cof }}' \n    AND (hp.unidades_ok + hp.unidades_nok + hp.unidades_repro) > 0\n    AND YEAR(ho.Fecha_ini) >= YEAR(GETDATE())\nGROUP BY \n    ho.cod_of, \n    ho.Desc_of, \n    ho.Unidades_planning,\n    ho.Fecha_ini,\n    ho.Fecha_fin,\n    ho.Fecha_entrega,\n    ho.Activo\nORDER BY MIN(hp.fecha_ini) DESC;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [944, 48],
      "id": "sql-query",
      "name": "Microsoft SQL",
      "credentials": {
        "microsoftSql": {
          "id": "op1E2bL9q09CUAxH",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=cache:fechas:{{ $('edit-fields').item.json.cof }}",
        "value": "={{ JSON.stringify($json) }}",
        "expire": true,
        "ttl": 30
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1088, 48],
      "id": "redis-set",
      "name": "Redis Set Cache",
      "credentials": {
        "redis": {
          "id": "Lrhc8rOAXwUSQ4SQ",
          "name": "REDISLOCAL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * N8N Function Node - Calculadora de OFs\n * ✅ CORRIGIDA: Proteção contra \"Invalid time value\"\n * Funciona com dados do SQL (frescos) ou Redis (cache)\n */\n\nconst items = $input.all();\n\n// ===== DETECTAR ORIGEM DOS DADOS =====\nfunction parseInput(item) {\n    const data = item.json;\n    \n    // Se vem do Redis cache\n    if (data.propertyName) {\n        try {\n            const cached = typeof data.propertyName === 'string'\n                ? JSON.parse(data.propertyName)\n                : data.propertyName;\n            \n            // Se já processado, retornar direto\n            if (cached.producao) {\n                return { skipProcessing: true, data: cached };\n            }\n            \n            return { skipProcessing: false, data: cached };\n        } catch (err) {\n            console.error('Erro ao fazer parse do cache:', err);\n            throw err;\n        }\n    }\n    \n    // Dados frescos do SQL\n    return { skipProcessing: false, data };\n}\n\n// ===== FUNÇÕES AUXILIARES =====\n\nfunction toISOSafe(date) {\n    if (!date || isNaN(date.getTime())) {\n        return null;\n    }\n    return date.toISOString();\n}\n\nfunction isValidDate(date) {\n    return date && !isNaN(date.getTime());\n}\n\nfunction formatDateBR(dateString) {\n    if (!dateString) return 'N/A';\n    const date = new Date(dateString);\n    if (isNaN(date.getTime())) return 'N/A';\n    const dd = String(date.getDate()).padStart(2, '0');\n    const mm = String(date.getMonth() + 1).padStart(2, '0');\n    const yyyy = date.getFullYear();\n    const hh = String(date.getHours()).padStart(2, '0');\n    const mi = String(date.getMinutes()).padStart(2, '0');\n    const ss = String(date.getSeconds()).padStart(2, '0');\n    return `${dd}/${mm}/${yyyy} ${hh}:${mi}:${ss}`;\n}\n\nfunction formatDuration(h) {\n    if (h <= 0) return '0m';\n    if (h < 1) return `${Math.round(h * 60)}m`;\n    const hh = Math.floor(h);\n    const mm = Math.round((h - hh) * 60);\n    return mm > 0 ? `${hh}h ${mm}m` : `${hh}h`;\n}\n\nfunction formatDurationSCADA(h) {\n    if (h <= 0) return '0.00h';\n    return `${h.toFixed(2)}h`;\n}\n\n// ===== PROCESSAMENTO =====\nreturn items.map(item => {\n    const parsed = parseInput(item);\n    \n    if (parsed.skipProcessing) {\n        return { json: parsed.data };\n    }\n    \n    const data = parsed.data;\n    const now = new Date();\n    \n    const planning = parseInt(data.quantidade_planejada) || 0;\n    const ok = parseInt(data.unidades_ok) || 0;\n    const nok = parseInt(data.unidades_nok) || 0;\n    const rw = parseInt(data.unidades_rw) || 0;\n    const total_producido = ok + nok + rw;\n    const piezas_faltantes = Math.max(0, planning - total_producido);\n    \n    const seg_por_pieza = parseFloat(data.tiempo_medio_por_pieza_segundos) || 0;\n    const velocidad_piezas_hora = seg_por_pieza > 0 ? 3600 / seg_por_pieza : 0;\n    \n    const tiempo_restante_segundos = piezas_faltantes * seg_por_pieza;\n    const tiempo_restante_horas = tiempo_restante_segundos / 3600;\n    const fecha_fin_estimada = new Date(now.getTime() + (tiempo_restante_segundos * 1000));\n    \n    const data_inicio_real = new Date(data.data_inicio_real);\n    const is_valid_inicio = isValidDate(data_inicio_real);\n    const tiempo_decorrido_ms = is_valid_inicio ? (now - data_inicio_real) : 0;\n    const tiempo_decorrido_horas = tiempo_decorrido_ms / (1000 * 60 * 60);\n    \n    const porcentaje_completado = planning > 0 ? (total_producido / planning * 100) : 0;\n    \n    let status;\n    if (porcentaje_completado >= 100) {\n        status = 'FINALIZADA';\n    } else if (total_producido > 0) {\n        status = 'EN_PRODUCCION';\n    } else {\n        status = 'PENDIENTE';\n    }\n    \n    const data_fim_planejada = new Date(data.data_fim_planejada);\n    const is_valid_planejada = isValidDate(data_fim_planejada);\n    const esta_atrasada = is_valid_planejada ? (fecha_fin_estimada > data_fim_planejada) : false;\n    const atraso_ms = is_valid_planejada ? (fecha_fin_estimada - data_fim_planejada) : 0;\n    const atraso_horas = atraso_ms / (1000 * 60 * 60);\n    \n    return {\n        json: {\n            codigo_of: data.codigo_of,\n            descricao: data.descricao,\n            status: status,\n            ativo: Boolean(data.ativo),\n            \n            producao: {\n                planejadas: planning,\n                ok: ok,\n                nok: nok,\n                rw: rw,\n                total_producido: total_producido,\n                faltantes: piezas_faltantes,\n                completado: `${porcentaje_completado.toFixed(2)}%`\n            },\n            \n            velocidade: {\n                piezas_hora: Math.round(velocidad_piezas_hora),\n                segundos_pieza: seg_por_pieza.toFixed(2),\n                formato_scada: `${Math.round(velocidad_piezas_hora)} u/h ${seg_por_pieza.toFixed(2)} seg/pza`\n            },\n            \n            tempo: {\n                inicio_real: is_valid_inicio ? formatDateBR(data_inicio_real) : 'N/A',\n                fim_estimado: formatDateBR(fecha_fin_estimada),\n                tempo_decorrido: formatDuration(tiempo_decorrido_horas),\n                tempo_decorrido_horas: tiempo_decorrido_horas.toFixed(2),\n                tempo_restante: formatDurationSCADA(tiempo_restante_horas),\n                tempo_restante_horas: tiempo_restante_horas.toFixed(2),\n                tempo_restante_formato: formatDuration(tiempo_restante_horas)\n            },\n            \n            planejamento: {\n                inicio_planejado: formatDateBR(data.data_inicio_planejada),\n                fim_planejado: is_valid_planejada ? formatDateBR(data_fim_planejada) : 'N/A',\n                data_entrega: formatDateBR(data.data_entrega),\n                esta_atrasada: esta_atrasada,\n                atraso_horas: esta_atrasada ? atraso_horas.toFixed(2) : 0\n            },\n            \n            display: {\n                linha1: `Produto: ${data.descricao}`,\n                linha2: `Ordem: ${data.codigo_of}`,\n                linha3: `Status: ${status}`,\n                linha4: `Velocidad: ${Math.round(velocidad_piezas_hora)} u/h ${seg_por_pieza.toFixed(2)} seg/pza`,\n                linha5: `Completado: ${porcentaje_completado.toFixed(2)}%`,\n                linha6: `Tiempo restante: ${tiempo_restante_horas.toFixed(2)}h`,\n                linha7: `Fecha Inicio: ${is_valid_inicio ? formatDateBR(data_inicio_real) : 'N/A'}`,\n                linha8: `Fecha fin est.: ${formatDateBR(fecha_fin_estimada)}`,\n                linha9: `${planning} Planificadas | ${ok} OK | ${nok} NOK | ${rw} RW`\n            },\n            \n            raw: {\n                data_inicio_real_iso: toISOSafe(data_inicio_real),\n                data_fim_estimada_iso: toISOSafe(fecha_fin_estimada),\n                tempo_restante_segundos: tiempo_restante_segundos,\n                velocidad_real: velocidad_piezas_hora,\n                porcentaje_decimal: porcentaje_completado / 100\n            }\n        }\n    };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1248, 48],
      "id": "code-calculadora",
      "name": "Code - Calculadora OFs"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "fechaini-field",
              "name": "fechaini",
              "value": "={{ $json.tempo.inicio_real }}",
              "type": "string"
            },
            {
              "id": "fechafin-field",
              "name": "fechafin",
              "value": "={{ $json.tempo.fim_estimado }}",
              "type": "string"
            },
            {
              "id": "tiempoRestante-field",
              "name": "tiempoRestante",
              "value": "={{ $json.tempo.tempo_restante_horas }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [1408, 48],
      "id": "edit-fields-final",
      "name": "Edit Fields - Extract Response"
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [1600, 48],
      "id": "respond-webhook",
      "name": "Respond to Webhook"
    }
  ],
  "connections": {
    "webhook": {
      "main": [[{"node": "edit-fields", "type": "main", "index": 0}]]
    },
    "edit-fields": {
      "main": [[{"node": "redis-get", "type": "main", "index": 0}]]
    },
    "redis-get": {
      "main": [[{"node": "if-cache-exists", "type": "main", "index": 0}]]
    },
    "if-cache-exists": {
      "main": [
        [{"node": "code-calculadora", "type": "main", "index": 0}],
        [{"node": "sql-query", "type": "main", "index": 0}]
      ]
    },
    "sql-query": {
      "main": [[{"node": "redis-set", "type": "main", "index": 0}]]
    },
    "redis-set": {
      "main": [[{"node": "code-calculadora", "type": "main", "index": 0}]]
    },
    "code-calculadora": {
      "main": [[{"node": "edit-fields-final", "type": "main", "index": 0}]]
    },
    "edit-fields-final": {
      "main": [[{"node": "respond-webhook", "type": "main", "index": 0}]]
    }
  },
  "pinData": {}
}

